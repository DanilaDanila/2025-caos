0b1010 ' 0111

0b1010 = 2^1 + 2^3 = 2 + 8 = 10
       = 0xa

0b0111 = 2^0 + 2^1 + 2^2 =
       = 1 + 2 + 4 = 7

1 byte = 8 bits
0b10100111
0xa7


1 byte
0b00000000

3
0b00000011

-3

Постулат: знак надо где-то хранить

> давайте хранить знак в 1-ом бите


Группа:
    это множество с операцией над ними
    (*)
    1. ассоциативность
        (a * b) * c = a * (b * c)
    2. существование единицы
        \exists 1
        1 * a = a * 1 = a
    3. существование обратного
        \forall a \exists a'
        a * a' = a' * a = 1

a mod (100)

Z_{100} = {0, 1, 2, 3, ... 99}



1 byte = 8 bit
0...255

Z_{256} = {0, 1, 2, ... 255}
        
2 + ? = 1 mod (256)
2 + 255 = 257 mod (256) = 1 mod (256)


0 + a = a + 0 = a

Z_{256}
a ~ a' (обратный)
a + a' = a' + a = 0

0 ~ 0   = -0 = 0
1 ~ 255 = -1
2 ~ 254 = -2
3 ~ 253 = -3
4 ~ ...
127 ~ 129 = -127
      128 = -128
...


Z_{256} = 1 byte (со знаком)
-128, -127, ..., -1, 0, 1, 2, ..., 127
128, 129, ..., 255, 0, 1, 2, ..., 127 -- без знака


Z_{sizeof(int)}


# Little Endian / Big Endian
Little - младшие разряды впереди
Big - старшие разряды впереди

0x01020304
01 - самый старший разряд (байт)
04 - самый младший разряд (байт)


register0 = 0x01020304

SAVE TO MEMORY

Little Endian:
    -> 0x04 0x03 0x02 0x01

Big Endian:
    -> 0x01 0x02 0x03 0x04

uint64_t x = 10 = 0x...0a
--> 0a 00 00 ... 00

uint8_t *y --> 0a


---

кодировка - ~таблица присваивания буквам номера

