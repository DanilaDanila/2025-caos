---
weight: 40
title: "x86_64 assembler"
enableEmoji: true
bookCollapseSection: true
---

# x86_64 assembler


## Про ассемблер

Пожалуйста, посмотрите запись лекции и [полистайте презентацию](slides/x86.slides.html#/3/0/3).

Про команды и синтаксис тут будет мало.
Но будет про то, как начать понимать и писать на языке ассемблера.


## 0. Адресное пространство процесса

В начале давайте представим, что у нас запущенна какая-нибудь программа (hello world).

У нас есть код, который, мы написали, есть переменные и константы, которые мы завели.
Есть что-то из стандартной библиотеки (printf или puts)...
и всё это существует не в вакууме.

У процесса, который мы запускаем, есть адресное пространство, в котором он существует.
Каждый адрес (от 0x00...0 до 0xff...f) соответствует какой-то секции или "ничему".

Подробнее про "ничего" будет через 2 семинара; пока считайте, что адрес всегда попадает в какую-нибудь секцию)


{{% columns %}}

Все эти секции, при запуске, помещаются по соответствующим адресам (подробнее - когда-нибудь на лекции).

Нас сейчас интересует .stack

Это тот самый "стек", на котором хранятся локальные переменные и адреса возврата.

Место под стек выделяется в момент запуска.
И с этой областью памяти мы сейчас будем работать много.

<--->

![godbolt](../../../sems/x86_64/process_memory_layout.png)

{{% /columns %}}

На вершину стека указывает регистр `rsp`.
Когда процессор читает и выполняет инструкции, он иногда встречает инструкцию `call`, которая нужна для вызова функций.

Вызов функции состоит из 2-х частей - сохранение _адреса возврата_ и переход к соответствующей ветке.
Возврат из функции - из чтения _адреса возврата_ и перехода к нему.

Вот пример запущенного hello world:

```asm
0x555555555139 <main>           push   %rbp
0x55555555513a <main+1>         mov    %rsp,%rbp
0x55555555513d <main+4>         lea    0xec0(%rip),%rax        # 0x555555556004
0x555555555144 <main+11>        mov    %rax,%rdi
0x555555555147 <main+14>        call   0x555555555030 <puts@plt>
0x55555555514c <main+19>        mov    $0x0,%eax
0x555555555151 <main+24>        pop    %rbp
0x555555555152 <main+25>        ret
```

- левая колонка - адрес в памяти, по которому расположена инструкция.
- <label+X> - смещение в `X` байт относительно метки `label`
- дальше идут дезассемблированная инструкция на ассемблере


Инструкция `call` находится в ячейке (ячейках) по адресу `0x555555555147`.
_Адрес возврата_ - это адрес следующей инструкции, т.е. - `0x55555555514c`.

Конкретно, что происходит при выполнении `call   0x555555555030 <puts@plt>`
1. на стек сохраняется `0x55555555514c`
    - сдвигается `rsp` вниз на 8 ячейки
    - по этому адресу записывается `0x55555555514c`
2. происходит переход на `0x555555555030`
    - можно сказать, что это записывается в регистр `rsp`
    - следующей исполненной инструкции будет инструкция по адресу - `0x555555555030`

Последней инструкцией функции `puts` (как и любой другой) будет инструкция `ret`.
Она делает прямо противоположные вещи - читает со стека _адрес возврата_ и выполняет переход к нему.
Таким образом после выполнения функции `puts` исполнение вернётся к `0x55555555514c`.

## 1. Посмотрите примеры кода на языке ассемблера

Как вариант можно остановить сборку Си-шного кода на одном из промежуточных этапов.
Т.е. запустить `gcc - S` или `gcc -c` (и потом запустить дизассемблер через `objdump -d` и получить ассемблерный код).


Либо воспользоваться [godbolt.org](https://godbolt.org/) - написать код, выбрать компилятор, и дальше сайт подскажет,
какая строчка Си-шного кода переходит в какие ассемблерные инструкции.

![godbolt](../../../sems/x86_64/godbolt.png)

Ну и давайте на этом примере построчно разберём, что происходит.

Для начала просто ещё раз посмотрите на код (тут или в godbolt).
Попытайтесь на интуитивном уровне понять, что сложение на самом деле происходит))

{{% columns %}}

#### C source code

```c
int sum3(int num1, int num2, int num3) {
    int num12 = num1 + num2;
    int num123 = num12 + num3;

    return num123;
}
```

<--->

#### Asm code

```asm
sum3:
    // (int num1, int num2, int num3)
    push    rbp
    mov     rbp, rsp
    mov     DWORD PTR [rbp-20], edi
    mov     DWORD PTR [rbp-24], esi
    mov     DWORD PTR [rbp-28], edx

    // int num12 = num1 + num2;
    mov     edx, DWORD PTR [rbp-20]
    mov     eax, DWORD PTR [rbp-24]
    add     eax, edx
    mov     DWORD PTR [rbp-4], eax

    // int num123 = num12 + num3;
    mov     edx, DWORD PTR [rbp-4]
    mov     eax, DWORD PTR [rbp-28]
    add     eax, edx
    mov     DWORD PTR [rbp-8], eax

    // return num123;
    mov     eax, DWORD PTR [rbp-8]
    pop     rbp
    ret
```

{{% /columns %}}



А теперь построчно и с подробными комментариями

```asm
// В ассемблере нету функций, и переменных, и if, и циклов... в привычном смысле
// Но зато там есть метки. Тут задаётся метка, с которой начинается функция sum3
sum3:
    // дальше необходимо выделить память под локальные переменные
    // sub rsp, 28 - не происходит, т.к. компилятор соптимизировал
    //               если мы в функции не вызываем других функций - нам не
    //               обязательно двигать stack pointer; весь стек уже доступен

    // fastcall calling convention требует, чтоб вызываемая функция сохраняла
    // значение регистров rbx, rsp, rbp, r12-15
    // если мы в коде функции хотим использовать эти регистры - мы должны потом
    // вернуть им их изначальные значения
    push    rbp

    // дальше можно выделить стекфрейм - место под хранение локальных переменных
    // тут не двигается rsp (нет нужды), в rbp кладётся конец стек фрейма
    mov     rbp, rsp

    // теперь используя rbp адресуются ячейки под локальные переменные
    // они тут НЕ СОЗДАЮТСЯ - память для них уже существует на стеке
    // память разбивается на "куски" по 4 байта (sizeof(int) = 4)
    // и используется под переменные по необходимости
    mov     DWORD PTR [rbp-20], edi
    mov     DWORD PTR [rbp-24], esi
    mov     DWORD PTR [rbp-28], edx

    // по адресу rbp-20 лежит первый аргумент sum3 (num1)
    // по адресу rbp-25 - второй (num2)
    // они загружаются в свободные регистры
    mov     edx, DWORD PTR [rbp-20]
    mov     eax, DWORD PTR [rbp-24]
    add     eax, edx
    mov     DWORD PTR [rbp-4], eax
    // обратите внимание - результат сохраняется в другие ячейки (переменную)

    // теперь нужно сложить промежуточный результат num12
    // с оставшимся аргументом - num3
    // они снова загружаются в свободные регистры и потом складываются
    mov     edx, DWORD PTR [rbp-4]
    mov     eax, DWORD PTR [rbp-28]
    add     eax, edx
    mov     DWORD PTR [rbp-8], eax
    // и снова сохранение в новые ячейки (новую переменную)

    // осталось вернуть результат
    // в ячейке pbp-8 лежит результат сложения 3-х чисел
    // результат возвращается в регистре rax (eax / ax) потому что fastcall
    // а ещё на стеке сохраналось старое значение rbp, которое там лежало
    // до вызова нашей функции - его надо восстановить
    // загружаем сумму в eax
    mov     eax, DWORD PTR [rbp-8]
    // восстанавливаем rbp
    pop     rbp
    ret
```

Как вы возможно заметили, код не особо оптимальный.
Такой же результат можно было достичь сильно проще и оптимальнее ~~собрав с флагом -O3~~.
Например вот так:

```asm
// num1 = edi
// num2 = esi
// num3 = edx
sum3:
    // num1 += num2
    add edi, esi
    // (num1+=num2) += num3
    add edi, edx
    // в eax возвращается результат
    mov eax, edi
    ret
```

Проще - проще.
Быстрее - да (не на два порядка, но кратно быстрее).
Почему нам не сгенерировался такой код?

Потому что это сложно)
Хотя выдавать оптимальный код компиляторы умеют.

Если всё-таки собрать это с флагом `-O3`, то будет вот это
```asm
sum3:
    add     edi, esi
    lea     eax, [rdi + rdx]
    ret
```

это ещё быстрее и ещё проще)
возможно даже быстрее))

Второе сложение (num12 += num3) сделано через магию адресации - `[base + index * 1/2/4/8 + offset]` и совмещенно с
загрузкой результата в rax.
Подробнее - читайте про команду lea, она достаточно простая.


### А почему просто всегда не собирать оптимально? Зачем вообще -O0, -O1, -O2, -O3?

Почему сразу не выдавать оптимальный код?
Потому что это может быть долго (раз), не всегда нужно (два).

Программирование микроконтроллеров (embedded разработка) всегда связана с получением и отправкой логических сигналов
с ног микроконтроллера.
Эти ноги доступны для чтения / записи по конкретным адресам.
Их настройка тоже осуществляется через чтения / запись по другим конкретным адресам.

У вас буквально будет код вида
```c
// set high (1) to pin 7
#define GPIO_PINS 0x444000
(uint8_t)(GPIO_PINS + PIN_ADR_SHIFT * 7) |= 1;
```


А теперь вопрос - если компилятор спокойно избавляется от такого кода
```
    mov     DWORD PTR [rbp-4], eax
    mov     edx, DWORD PTR [rbp-4]
```

и просто сохраняет результат сразу в нужные регистры, что мешает ему выпилить весь код по настройке ног
микроконтроллера на нужный режим и на запись логических единиц?)
Ведь это тоже запись в случайные адреса (тем более откуда мы больше никогда не читаем).

На самом деле - ничего не мешает.
В компиляторах, созданных для embedded разработки, отключена почти вся(!) оптимизация.

---

Ну и это всё равно не единственная причина))
Если вы пишите драйвера устройств - магия "записи и чтения по случайным адресам" вам всё равно встретится.
И оптимизацию вам тоже придётся выключить)

Если интересно - можете посмотреть на реализацию `digitalWrite` для RaspberriPi [вот тут](https://github.com/WiringPi/WiringPi/blob/b2af17eea92238fa99dae5bf174b3cdf81b78656/wiringPi/wiringPi.c#L2359).
Эта функция выставляет логический сигнал (0 или 1) на соответствующей ноге этого маленького компьютера.
Она довольно простая - вы справитесь понять происходящее.

---

А ещё...
Компилятор не всегда справляется выдавать оптимальный код (даже с оптимизацией).
Если вы сражаетесь за доли долей секунд - будьте добры проверять за компилятором.


## 2. Давайте что-нибудь напишем

Если вас ниже будет смущать, что я использую то `eax`, то `rax` - не смущайтесь))

`sizeof(int) = 4`, поэтому `eax` достаточно.

Указатели - `rax`

### return 123

Ну как что-нибудь)
Очевидно это будет hello world!
**НЕТ!** ещё проще!
Будем писать программу, которая ничего не делает!

```asm
// hw.s

// по умолчанию у gas AT&T-синтаксис, поэтому
// говорим, что будет использовать Intel-синтаксис
.intel_syntax noprefix

// чтоб метки были видны из других модулей компиляции (aka других .o файлов)
// нужно это специально указать - иначе никто не увидит нашу функцию main
// функция main вызывается из стандартной библиотеки, так что нам это нужно)
.global main

// говорим, что "всё, что ниже" относится к секции .text
// т.е. к секции с op-кодами, которые можно читать и исполнять
.text

// ставим метку на начало функции
main:
    // давайте вместо скучного нуля вернём какой-нибудь 123
    // возвращаемое значение передается через eax (потому что fastcall)
    mov eax, 123

    // возращаемся в вызывающую функцию
    ret
```

Всё)
Было достаточно просто.

Теперь можем собрать и запустить
```bash
[danila@archlinux ~/caos_all/2025_caos/4_x86/examples]
$ gcc hw.s
[danila@archlinux ~/caos_all/2025_caos/4_x86/examples]
$ ./a.out
[danila@archlinux ~/caos_all/2025_caos/4_x86/examples]
$ echo $?
123
```

`echo $?` - позволяет вывести код возврата предыдущей команды
- `$` - взятие значения переменной
- `?` - переменная


### hello world

А теперь можно и hello world

```asm
.intel_syntax noprefix

.global main

.text

main:
    // в rdi помещаем первый (и единственный аргумент) аргумент puts
    // а именно - указатель на zero-terminated строку, которую нужно вывести    
    mov rdi, offset hw_str  
    // или lea rdi, [hw_str]

    // вызываем функцию puts
    call puts

    // возвращаем 0
    mov rax, 0
    ret

// другая секция - сюда помещаем данные
.data
hw_str: .asciz "hello, world in asm!"
//  |     |     |
//  |     |     `-- строка
//  |     `-------- штуку дальше сохранить как ASCII с нулём (Zero) на конце
//  `-------------- название метки, через неё будем ссылаться на ячейки со строками
```

Теперь собираем (обратите внимание на `-no-pie`)
```bash
gcc -no-pie hw.s
```

А вообще, собирать _Position-Independent Code (Executables)_ - это хорошо, поэтому давайте от избавимся от этого флага.

PIC (или PIE) - это код, секции в котором могут размещаться независимо друг от друга.
Чтоб написать так, нужно сделать доступ к меткам зависимым, например, от адреса текущей ячейки.


```asm
.intel_syntax noprefix

.global main

.text

main:
    // тут вся магия - считаем смещение
    // от текущей ячейки с инструкцией до нашей строки
    lea rdi, [rip + hw_str]
    call puts

    mov rax, 123
    ret

.data

hw_str: .asciz "hello, world in asm!"
```

```bash
[danila@archlinux ~/caos_all/2025_caos/4_x86/examples]
$ gcc hw.s
[danila@archlinux ~/caos_all/2025_caos/4_x86/examples]
$ ./a.out
hello, world in asm!
```

### mul by five

Будем получать от пользователя число, умножать его на 5 и выводить.
Умножение на 5 сделаем отдельной функцией.

```asm
// mul5.s

.intel_syntax noprefix

.global main
// mul5 используется только тут - её "глобализировать" не обязательно

.text

mul5:
    // почитайте описание команды mul
    // она чуть сложнее, чем add

    // первый операнд команды mul - eax
    // поэтому загружаем туда переданный аргумент
    mov eax, edi

    // второй аргумент - ячейка или регистр
    // поэтому кладём 5 в ebx
    mov ebx, 5

    // умножаем
    mul ebx

    // после умножения результат лежит в паре регистров edx:eax
    // почему - а потому что))
    // умножение двух ЦИФР - это число, максимальный результат даёт 9x9
    // т.е. 9х9 = 81
    // если бы регистры были цифрами - нам бы потребовалось два - 8 и 1
    // с командой mul точно так же
    // eax * ebx может не влезть в eax
    // поэтому результат записывается в пару edx:eax
    // eax сохранит младшую половину, а edx - старшую

    // сейчас - забьём на переполнение, поэтому просто вернём результат
    // который уже лежит в eax)
    ret

main:
    // нам нужно 4 байта, чтоб хранить int
    // но fastcall требует выравнивания в 16 байт
    // поэтому выделим сразу 16)
    push rbp
    mov rbp, rsp
    sub rsp, 16

    // вызываем scanf(scanf_str, &input_to_store_in)
    lea rdi, [rip + scanf_str]
    // у нас целых 16 байт свободно, сохраним ввод туда
    lea rsi, [rbp]
    call scanf

    // читаем в edi введённый int
    // и вызываем функцию для умножения его на 5
    mov edi, dword ptr [rbp]
    call mul5

    // printf(printf_result_str, input_to_store_in, mul5_result)
    lea rdi, [rip + printf_result_str]
    mov esi, dword ptr [rbp]
    // mul5 вернул результат в eax (потому что fastcall)
    // поэтому просто кладём результат в edx
    mov edx, eax
    call printf

    // освобождаем память и возращаем 0 в конце
    add rsp, 16
    pop rbp
    mov eax, 0
    ret

.data
scanf_str: .asciz "%d"
printf_result_str: .asciz "%d * 5 = %d\n"
```

Собираем и проверяем

```bash
[danila@archlinux ~/caos_all/2025_caos/4_x86/examples]
$ gcc mul5.s
[danila@archlinux ~/caos_all/2025_caos/4_x86/examples]
$ ./a.out
123
123 * 5 = 615
[danila@archlinux ~/caos_all/2025_caos/4_x86/examples]
$ ./a.out
44231
44231 * 5 = 221155
```

Вроде работает


## 3. а как тестить?

Собирать и запускать.
Отладчик вам в помощь.

- eсли не боитесь терминала - время освоить [gdb](/2025-caos/docs/theory/devools/debugger/#gdb).
- eсли не боитесь терминала и готовы освоить инструмент, превращающий вас в оружие - **radare2**.
- eсли боитесь терминала - [попробуйте edb](https://github.com/eteran/edb-debugger);
    он с графическим интерфейсом и прост как тапок.
- если хотите интегрированный в IDE и настраивать поменьше - то
    * [CLion](https://www.jetbrains.com/ru-ru/clion/) (большой и пугающий)
    * [QtCreator](https://www.qt.io/product/development-tools) (не такой большой и страшный);
        если будете качать QtCreator - качайте только ide, без либы Qt.
- если (зачем-то) хотите мощный gui инструмент, способный разобрать компьютерный вирус на атомы - **Ghidra** или **IDA Pro**
    (но это оверкилл сейчас, не надо)
